---
title: C26418 | Documentos de Microsoft
ms.date: 11/15/2017
ms.prod: visual-studio-dev15
ms.technology: vs-ide-code-analysis
ms.topic: conceptual
f1_keywords:
- C26418
helpviewer_keywords:
- C26418
ms.assetid: d2c84a40-8a5d-4018-92c2-6498cdd9b541
author: mikeblome
ms.author: mblome
manager: douge
ms.workload:
- multiple
ms.openlocfilehash: 979dfc28d9c44de05250518d64a1391f26d37cc7
ms.sourcegitcommit: e13e61ddea6032a8282abe16131d9e136a927984
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 04/26/2018
ms.locfileid: "31885404"
---
# <a name="c26418-novalueorconstrefsharedptr"></a>C26418 NO_VALUE_OR_CONST_REF_SHARED_PTR
"Parámetro de puntero compartido no copiarlo o moverlo. Usar T * o T & en su lugar. "

**Directrices de núcleo de C++**: R.36: toman una shared_ptr const<widget>& parámetro expresar que puede mantener un recuento de referencias para el objeto

Si el parámetro de puntero compartido se pasa por valor o referencia a un objeto constante que se espera que función tomará el control de duración de su objeto de destino sin afectar a la del autor de la llamada. El código debe copiar o se mueve el parámetro de puntero compartido a otro objeto de puntero compartido o pasar más para otro código mediante la invocación de funciones que aceptan punteros compartidos. Si esto no es el caso, a continuación, puntero sin formato o una referencia puede ser factible.

## <a name="remarks"></a>Comentarios
-  Esta comprobación reconoce std::shared_pointer y tipos definidos por el usuario que están probables que se comportan como punteros compartidos. Para los punteros compartidos definidos por el usuario se esperan que las siguientes características:
-  sobrecarga de desreferenciación o de acceso a miembros de operadores (públicos y no se han eliminado);
-  constructor de copias o el operador de asignación de copia (público y no se han eliminado);
-  destructor público que no se eliminan ni su valor predeterminado. Destructores vacíos todavía se cuentan como definido por el usuario.

## <a name="example"></a>Ejemplo
complicación innecesarios de la interfaz

```cpp
template<class T>
std::string to_string(const std::shared_ptr<T> &e) // C26418, also C26415 SMART_PTR_NOT_NEEDED
{
    return !e ? null_string : e->to_string();
}
```

## <a name="example"></a>Ejemplo
complicación innecesarios de la interfaz - simplificado

```cpp
template<class T>
std::string to_string(const T *e)
{
    return !e ? null_string : e->to_string();
}
```
